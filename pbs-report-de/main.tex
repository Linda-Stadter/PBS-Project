\documentclass[a4paper]{paper} 
\usepackage[ngerman]{babel}  
\usepackage[margin=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{natbib}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}
\renewcommand{\eqref}[1]{Eq.~(\ref{#1})}
\newcommand{\figref}[1]{Fig.~\ref{#1}}
\sloppy
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

%% <---------------- fill according to your project --------------
\newcommand{\ProjectTitle}{Echtzeit SPH Wasserkanal}
\newcommand{\StudentNames}{Peter Wichert, Kirill Menke, Linda Stadter}
%% <--------------------------------------------------------------

\sectionfont{\large\sf\bfseries\color{black!70!blue}} 
\title{Physikalisch-basierte Simulation in der Computergraphik}
\subtitle{Schriftliche Ausarbeitung\\
\hfill\includegraphics[height=2cm]{fau-logo-tech.pdf}
\vspace{-2cm}}
\author{\ProjectTitle} 
\begin{document} 
\twocolumn[\maketitle 
\textbf{\StudentNames} \\
\hrule\bigskip
]

%neuneuneu
%% <--------------------------------------------------------------
%% <--------------------------------------------------------------

\section{Einleitung} 
%Bla Bla über Wassersimulationen und über #SPH 
%vll irgendwas mit blender oder so

Das Projekt soll einen realistischen Wasserfluss in einer begrenzten 3D-Umgebung in Echtzeit simulieren. %TODO vll satz über nromales partikelverhalten (zittern ect) sowie box interaktion
Als Inspiration dient das Kinderspielzeug 'Aquaplay', bei dem Kinder über Schleusen, Kurbeln, Pumpen oder Schranken den Wasserfluss verändern können. 

%Eine finale Simulation soll das Wasser in Bewegung in einer Art Kanal/Fluss sehen.
Zur Visualisierung des Wassers sollen zunächst kugelförmige Objekte dienen, welche durch Screen Space Rendering oder Marching Cubes zu realistisch aussehendem Wasser erweitert werden könnten. 

Für ein ausreichend detailliertes Verhalten der Simulation werden etwa 30.000 Partikel simuliert. Als Kriterium für Echtzeitanforderungen sollen 30 Bilder pro Sekunde erreicht werden. Dies soll auf handelsüblicher Hardware wie der NVIDIA RTX 2070 möglich sein, ohne die Anzahl der Partikel zu verringern. 
%TODO habt ihr eine 2070? ich habe eine 1070

Als Entwicklungsumgebung dient die Spiel-Engine Unity, welche hauptsaechlich fuer das Rendering eingesetzt werden soll. Echtzeit-Interaktionen lassen sich mit dieser Laufzeitumgebung einfach umsetzen, was einen weiteren Vorteil darstellt. Ausserdem bietet Unity eine uebersichtliche Nutzeroberflaeche.

\section{Theorie}
Unsere Echtzeit Wassersimulation basiert hauptsaechlich auf der Methode der Geglaetteten Teilchen-Hydrodynamik (SPH), welche durch durch eine verbesserte Suche der Nachbarpartikel beschleunigt werden soll. Zur numerischen Integration wird sowohl das Leapfrog-Verfahren als auch das explizierte Euler-Verfahren eingesetzt.
\subsection{Wissenschaftlicher Hintergrund}
Die Methode von SPH wurde erstmalig von Gingold und Monaghan \citep{gingold1977smoothed} und Lucy \citep{lucy1977numerical} vorgestellt. Urspruenglicherweise wurde sie dabei verwendet, um astrophysikalische Probleme wie die Dynamiken von Sternen darzustellen.

Müller et al. \citep{muller2003particle} wandte zuerst SPH für Computergrafik Simulationen in Echtzeit an. Es wurde eine Methode gefunden, die schnell genug war, bis zu 5.000 Partikel in interaktiven Systemen abzubilden.


\subsection{SPH mit effizienter Nachbarsuche}

Bei SPH wird die zu simulierende Flüssigkeit durch eine endliche Anzahl an Partikeln diskretisiert. Die Partikel interagieren innerhalb eines bestimmten Radius $h$ miteinander und besitzen eigene physikalische Eigenschaften wie  Dichte, Masse oder Druck.

Die Nachbarpartikel eines Partikels sind die Menge der Partikel, welche sich innerhalb von $h$ befinden und somit Einfluss auf den Partikel besitzen. Die Suche dieser Nachbarpartikel stellt einen sehr aufwaendigen Schritt des SPH-Algorithmus dar. Um diese effizient zu finden, teilen wir den Raum in ein uniformes Gitter auf. Eine Zelle besitzt die Grösse des Radius $h$, sodass die Nachbarpartikel nur in den anliegenden 26 Zellen und in der Zelle des Partikels gesucht werden müssen. Durch ihre Positionen im Raum werden die Partikel je einer Zelle zugewiesen. Dies erfolgt zunaechst durch eine Diskretisierung jeder Partikelposition $(x,y,z)$ in \eqref{discretize_position}. 
\begin{equation}
\label{discretize_position}
(i, j, k) = (\floor*{\frac{x}{h}}, \floor*{\frac{y}{h}}, \floor*{\frac{z}{h}})
\end{equation}
Anschliessend kann der diskretisierte Zellenwert in Kombination mit der Hash-Funktion aus \eqref{hash_function} eingesetzt werden. Diese bildet eine 3D-Position eines Partikels auf einen flachen 1D-Wert ab.

\begin{equation}
\label{hash_function}
hash(i,j,k) = (i\ p_1 \ \boldsymbol{xor} \ j\ p_2\ \boldsymbol{xor}\ k\ p_3)\ \boldsymbol{mod}\ n
\end{equation}
Die Variable $n$ stellt die Anzahl der Zellen beziehungsweise der Partikel dar und $p_1$, $p_2$ und $p_3$ sind große Primzahlen. Dies wird Spatial Hashing genannt und wird eingesetzt, damit eine endliche Anzahl an Zellen für einen unendlich grossen Raum ausreicht. \citep{muller2003optimized}

Dann können die Partikel anhand ihrer zugewiesenen Zelle sortiert werden. Für jede Zelle wird der Abstand zu dem ersten Partikel der Zelle gespeichert. Diese Idee wurde 2008 von Nvidia vorgestellt. \citep{Nvidia}
\begin{equation}
\label{force}
\vec{f} = \vec{f}^{pressure} + \vec{f}^{viscosity} + \vec{f}^{external}
\end{equation}


\begin{equation}
\label{density}
\rho_i = \sum_i{m_j W_{ij}}
\end{equation}



\begin{equation}
\label{pressure}
p_i=K(\rho-\rho_0)
\end{equation}

\begin{equation}
\label{pressure_tait}
p_i = k((\frac{\rho}{\rho_{0}})^{\gamma}-1)
\end{equation}

\begin{equation}
\label{force_pressure}
\vec{f}^{pressure}_{i} = - \sum_{j}m_{j}(\frac{p_{i}}{\rho_{i}^2} +\frac{p_{j}}{\rho_{j}^2})\bigtriangledown W(\vec{r}_{i}-\vec{r}_{j},h)
\end{equation}

\begin{equation}
\label{force_external}
\vec{f}^{external}_{i} = \vec{g}
\end{equation}

\begin{equation}
\label{force_viscosity}
\vec{f}^{viscosity}_{i} = \mu \sum_{j}m_{j}\frac{\vec{v}_{i} - \vec{v}_{j}}{\rho_{j}}\bigtriangledown^2 W(\vec{r}_{i}-\vec{r}_{j},h)
\end{equation}

\paragraph{Smoothing Kernels}

\begin{equation}
\label{poly6}
W_{poly6}(\vec{r},h) = \frac{315}{64 \pi h^9} 
\begin{cases}
(h^2-|\vec{r}|^2)^3, \\ \text{falls } 0 \leq |\vec{r}| \leq h \\
\\
0, \\ \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{gradient_poly6}
\bigtriangledown W_{poly6}(\vec{r},h) = \frac{945}{32 \pi h^9} 
\begin{cases}
\vec{r}(h^2-|\vec{r}|^2)^2, \\ \text{falls } 0 \leq |\vec{r}| \leq h  \\
\\
0, \\ \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{spiky}
\bigtriangledown W_{spiky}(\vec{r},h) = -\frac{45}{\pi h^6} (h^2-r^2)^3
\begin{cases}
\frac{\vec{r}}{|\vec{r}|}(h-|r|)^2, \\ \text{falls } 0 \leq |\vec{r}| \leq h\\

\\ 0, \\ \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{viscosity}
\bigtriangledown^2 W_{viscosity}(\vec{r},h) = \frac{45}{\pi h^9} 
\begin{cases}
(h-|r|),

\\ \text{falls } 0 \leq |\vec{r}| \leq h \\
\\
0, 
\\ \text{sonst}
\end{cases}
\end{equation}


\subsection{Oberflächenspannung}
Um ein überzeugendes Verhalten bei Wasserspritzern und an der Wasseroberflaeche zu erzeugen wird zusätzlich die molekulare Attraktion und Repulsion zwischen Wassermolekülen modelliert. Das gewählte Modell folgt der Arbeit von \citep{SurfaceTension}.

Eine neue Kraft für Oberflächenspannung wird wie folgt in die bisherige Kraftberechnung eingefügt:
\begin{equation}
\label{force_with_surface}
\vec{f} = \vec{f}^{pressure} + \vec{f}^{viscosity} + \vec{f}^{external} + \vec{f}^{surface}
\end{equation}


Das molekulare Verhalten wird durch \eqref{cohesion} ausgedrückt. $\gamma$ sei hier ein von uns wählbarer Koeffizient.

Die Spline-Funktion aus \eqref{spline} sorgt ab einem gewählten Radius $h$ für die zunächst anziehende Wirkung, sowie den ansteigenden abstoßenden Effekt, sollten zwei Partikel zu nahe beieinander sein.

\begin{equation}
\label{spline}
C(r) = \frac{32}{64 \pi h^9}
\begin{cases}
(h-r)^3r^3,  &\text{falls }  2r > h \land r \leq h\\
2(h-r)^3r^3, &\text{falls } r  0 \land 2r \leq h\\
0,&\text{sonst}  
\end{cases}
\end{equation}



\begin{equation}
\label{cohesion}
\vec{f}_{i\leftarrow j}^{\text{cohesion}} = \gamma m_{i} m_{j} C(|\vec{x}_i - \vec{x}_j|)\frac{\vec{x}_i - \vec{x}_j}{|\vec{x}_i - \vec{x}_j|}
\end{equation}


Um zu verhindern, dass beim Formen eines Tropfens durch Oberflächenspannung, die Ausgangsposition der betroffenen Partikel maßgeblich die finale Form beeinflusst, fügen wir eine weitere Kraft aus \eqref{curvature} hinzu.
Diese sorgt dafür, dass Partikel-Mengen unabhängig von Ausgangsposition versuchen eine Kugelform einzunehmen und dadurch die Oberfläche ihres Tropfens minimieren.

Zunächst wird für jedes Partikel ein Normal-Vektor wie in \eqref{normal} berechnet. Hier sollen sich Partikel an der Oberfläche von denen innerhalb eines Wasserkörpers dadurch unterscheiden, dass letztere einen Normal-Vektor von $\sim \vec{0}$ besitzen. Hier würde das Benutzen eines geglättetes Feldes optimale Ergebnisse erreichen. (?)

\begin{equation}
\label{normal}
\vec{n}_{i} = h\sum_{j}\frac{m_{j}}{\rho_{j}}\bigtriangledown W (\vec{r}_{i}-\vec{r}_{j},h)
\end{equation}

\begin{equation}
\label{curvature}
\vec{f}_{i\leftarrow j}^{\text{curvature}} = -\gamma m_{i}(\vec{n}_i - \vec{n}_j)
\end{equation}

Um den Zusammenhalt von wenigen Partikeln an den von grösseren Gruppen anzugleichen, wird in \eqref{surface_tension} ein Korrekturfaktor beim Zusammensetzen (?) der Oberflächenspannung eingeführt.

\begin{equation}
	\label{surface_tension}
	\vec{f}_{i\leftarrow j}^{\text{surface}} = \frac{2\rho_{0}}{\rho_{i}+\rho_{j}} (\vec{f}_{i\leftarrow j}^{\text{cohesion}} + \vec{f}_{i\leftarrow j}^{\text{curvature}})
\end{equation}


\subsection{Integration}


Für die Implementation von Leapfrog wir eine von \citep{Leapfrog} vorgestellte Variation benutzt.

\begin{equation}
\label{leapfrog_v_i+1/2}
v_{i+1/2} = v_{i}+\frac{\Delta t}{2}a_{i}
\end{equation}
\begin{equation}
\label{leapfrog_r_i+1/2}
r_{i+1/2} = r_{i}+\frac{\Delta t}{2}v_{i}
\end{equation}
\begin{equation}
\label{leapfrog_v_i+1}
v_{i+1} = v_{i} + \Delta a_{i+1/2}
\end{equation}
\begin{equation}
\label{leapfrog_r_i+1}
r_{i+1} = r_{i} + \frac{\Delta t}{2} (v_{i} + v_{i+1})
\end{equation}

Der Raum der Partikel wird durch eine quadratische Box begrenzt. Kollisionen mit den Seiten der Box werden durch einfache Positionsabfragen behandelt. Diese verhindern, dass die Partikel die Begrenzungen überschreiten. Ausserdem werden die Geschwindigkeiten der entsprechenden Richtungen umgekehrt, um die Partikel von der Box abprallen zu lassen. Eine Dämpfungsvariable wird eingeführt, die die Geschwindigkeit dabei zusätzlich abmildern kann.

\section{Implementierung}
Das Projekt wird in der Laufzeit und Entwicklungsumgebung Unity implementiert. Dazu wird ein sogenanntes GameObject erstellt, welches ein eigens geschriebenes C\#-Skript zugewiesen wird. Dieses Skript wird verwendet, um die Simulation zu initialisieren und aufzurufen. %Dabei werden zunächst die notwendigen Arrays, Buffer, Partikel und Shader initialisiert.
Ein Zeitschritt wird mithilfe der Update-Funktion von Unity einmal pro Frame durchgeführt. Der eigentliche SPH-Algorithmus wird auf sieben Shader aufgeteilt, welche von der GPU ausgeführt werden. Es ist je ein Shader dafür zuständig, die Buffer zu initialisieren, die Partikel in Zellen einzuteilen, die Partikel anhand ihrer Zelle zu sortieren, die Dichte und im Anschluss die Force eines Partikels zu berechnen und zum Schluss den Integrationsschritt durchzuführen.

Die Positionen in x-,y- und z-Richtung eines Partikels werden diskretisiert und anschliessend gehasht, um daraus den flachen Zellindex zu bestimmen. Um die Anzahl der Hash-Kollisionen möglichst gering zu halten, werden die 8-stellige Primzahlen $73856093$, $19349663$ und $83492791$ eingesetzt und eine grosse Anzahl an Partikeln - und damit auch Zellen - benutzt.

Für das Sortieren der Partikel anhand ihrer zugewiesenen Zelle wird eine fertige Implementierung des Algorithmus Bitonisches Sortieren verwendet. Dieser Sortieralgorithmus kann parallel auf der GPU ausgeführt werden.

Das Einbeziehen der Nachbarpartikel bei der Berechnung der Dichte und im Anschluss der Force wird im Dichte- und im Force-Shader auf ähnliche Weise implementiert. Hierbei muss über die 27 möglichen Nachbarzellen iteriert werden. Mithilfe des zuvor gespeicherten Abstands kann dann effizient auf alle Partikel einer bestimmten Nachbarzelle zugegriffen werden. Zusätzlich wird überprüft, ob der Abstand zwischen den Partikeln kleiner als der Radius $h$ ist.

Im Integrations-Shader wird neben der Berechnung der Position und der Geschwindigkeit auch die Kollision mit der Box behandelt.

Die Partikel werden in der Update-Funktion in jedem Frame gerendert. Dazu wird eine von Unity vorgegebene Zeichen-Funktion aufgerufen, welche das gleiche Kugel-Mesh parallel auf der GPU zeichnet. Dadurch verhindern wir den unnötigen Overhead, eigenständige GameObjects pro Partikel zu erstellen. In diesem Schritt werden die Partikel anhand ihrer Dichte in einen blassen bis kräftigen Blauton gefärbt.

\begin{figure}[t]
	\centering
	\includegraphics[width=1\linewidth]{images/interface1.png}
	\caption{Oberfläche vor dem Start, um die entsprechenden Parameter der Simulation einzustellen.}
	\label{fig:interface1}
\end{figure}

\begin{figure}[t]
	\centering
	\includegraphics[width=1\linewidth]{images/interface2.png}
	\caption{Oberfläche während der Simulation, um die Parameter des SPH-Algorithmus anzupassen.}
	\label{fig:interface2}
\end{figure}

Neben dem GameObject, welches die Simulation behandelt, werden auch weitere Objekte benötigt. Der Raum, in welchem sich die Partikel bewegen können, wird durch eine Box begrenzt, welche zur Laufzeit erzeugt wird. Die Box wird dabei durch ein eigenes Skript kontrolliert, welches die Positionen der Seitenplatten anhand einer vorgegebenen Bodenplatte berechnet.
Ausserdem werden zwei Nutzeroberflächen benötigt, um Parameter einerseits vor dem Beginn der Simulation wie in Bild \ref{fig:interface1} und andererseits während der laufenden Simulation wie in Bild \ref{fig:interface2} einstellen und anpassen zu können. Dazu werden fertige UI-Elemente von Unity verwendet. Beim Starten der Simulation findet ein Szenenwechsel statt. Dadurch werden nicht mehr benötigte Objekte entfernt und neue Objekte eingeblendet.


\begin{algorithm}
	\caption{C\# Skript}\label{skript}
	\begin{algorithmic}[1]
		\State Berechne Parameter
		\State Initialisiere Partikel
		\State Initialisiere Buffer 
		\State Initialisiere Shader
		\While {true} \Comment{Unitys Update Schleife}
	
		\For {Zeitschritt $i+1/2$ und $i+1$}	
		\State Initialization Shader
		\State \Comment{Kurze Beschreibung zum Shader}
		\State Partition Shader
		\State Sort Shader
		\State Offset Shader
		\State Density Shader
		\State Normals Shader
		\State \hskip1.0em Oder eine Auflistung der Formeln
		\State Force Shader
		\State \hskip1.0em \ref{force_pressure}, \ref{force_with_surface}
		\State Integration Shader \Comment{\ref{leapfrog_r_i+1}, \ref{leapfrog_v_i+1}}
		\EndFor
		\EndWhile
	
	\end{algorithmic}
\end{algorithm}



\section{Ergebnisse und Evaluierung}

Um die Stabilität und Performance zu Testen wurden mehrere Iterationen der Simulation mit variierendem Zeitschritt und gleichen Parametern ausgeführt und für ca. 30 Minuten laufen gelassen. Getestet wurden Simulationen sowohl mit kontinuierliche Partikel-Erzeugung durch das Rohr, als auch mit Beginn aller Partikel in Boxform. Simulationen, die Leapfrog Integration benutzen, mit einem Zeitschritt $\leq 0.006$ Sekunden blieben dabei stabil. Eine  Simulation mit $\Delta t = 0.005$, dem konstanten Partikelerscheinen, 32.768 Partikeln und angegebenen Parametern beginnt mit $\sim$400 Frames pro Sekunde. Im Verlauf der Simulation sinken mit steigender Partikelzahl die FPS, bleiben aber immer über 60. Sobald der Spawnvorgang abgeschlossen ist, also keine neuen Partikel mehr hinzukommen und das Wasser zur Ruhe kommt, pendelt sich die Simulation bei $\sim$140 FPS ein. 



\paragraph{Test Hardware}\mbox{}\\
AMD Ryzen 7 3700X \\
NVIDIA GeForce GTX 1070\\
32GB RAM\\

Benötigte Daten:\\
Euler Stabilitätsgrenze\\
Leapfrog Stabilitätsgrenze\\
(vll noch je einmal mit/ohne Tait)\\

32768 Partikel, Leapfrog, Timestep X -> FPS\\
4096 Partikel, Leapfrog, Timestep X -> FPS\\
32768 Partikel, Euler, Timestep X -> FPS\\
4096 Partikel, Euler, Timestep X -> FPS\\
(vll noch mit/ohne Tait und Box/Rohr Test)\\

\begin{figure}[t]
	\centering
	\includegraphics[width=1\linewidth]{images/Unstable.png}
	\caption{Testsimulation wird instabil.}
	\label{fig:unstable}
\end{figure}
\begin{figure}[t]
	\centering
	\includegraphics[width=1\linewidth]{images/Pipe_End.png}
	\caption{Simulation mit 32.768 Partikeln und $\geq$ 60 FPS.}
	\label{fig:final_simulation}
\end{figure}




\section{Beiträge}
Kirill Menke hat über den SPH-Algorithmus recherchiert und die Methode gefunden, wie 
effizient auf die Nachbarpartikel zugegriffen werden kann. Er hat das Grundgerüst der Simulation in Unity aufgesetzt, sodass die einzelnen Schritte des SPH-Algorithmus auf der GPU ausgeführt werden können. Zusätzlich hat er das Rendering der Partikel implementiert , bei der Umsetzung des SPH-Algorithmus mitgewirkt und einen Modus zum vereinfachten Debuggen eingeführt. Außerdem hat er die Milestonepräsentation erstellt und vorgetragen. 

Linda Stadter hat ebenfalls bei der Umsetzung des SPH-Algorithmus mitgewirkt. Zusätzlich hat sie sich um das Erzeugen der Box und die Kollisionen der Kugeln mit den Seiten gekümmert. Sie hat die beiden Nutzeroberflächen umgesetzt, die Farbcodierung der Partikel eingeführt und ein kontinuierliches Erzeugen der Partikel umgesetzt. Außerdem hat sie die Projektplanpräsentation erstellt und vorgetragen, bei der Milestonepräsentation mitgewirkt und den finalen Bericht geschrieben.

Peter Wichert hat über die Leapfrog Integration und Oberflächenspannung recherchiert und diese implementiert. Zusätzlich hat er eine automatische Berechnung der Parameter in Kombination mit dem Erzeugen der Partikel eingeführt, den Debug-Modus ergänzt und Stabilitaets-Tests durchgefuehrt. Außerdem hat er die Milestone Präsentation erstellt und vorgetragen und am finalen Bericht mitgewirkt.



\section{Diskussion}
Durch das Verwendung von Spatial Hashing und der Sortierung nach Zellen laesst sich die Laufzeit der aufwaendigen Suche der Nachbarpartikel von $O(n^2)$ auf $O(n)$ reduzieren.
In Kombination mit der parallelen Ausfuehrung des SPH-Algorithmus auf der GPU lassen sich grosse Anzahlen an Partikeln in Echtzeit simulieren.
Hash-Collisions lassen sich leider nicht vermeiden und fallen bei einer sehr geringen Anzahl an Partikeln auf. Daher werden diese geringen Partikelanzahlen von der Simulation ausgeschlossen.
Da in unserem Modell die Geschwindigkeit $v$ abhängig ist von der Beschleunigung $a$ müssen wir für die Leapfrog Integration zwei Berechnungen der Kräfte ausführen. Der dadurch entstehende zusätzliche Rechenaufwand wird jedoch durch die erhöhte Stabilität und dadurch größere Zeitschritte übertroffen. 
Ungewiss ist ob zukünftige Erweiterungen in Sachen Visualisierung des Wassers und Interaktion mit Festkörpern die aktuelle Echtzeit-Performance signifikant negativ beeinflussen würden.
Allgemein zeigt die Simulation realistisches Wasserverhalten auf und kurzfristig könnte nur das Verhalten der Oberflächenspannung durch Glätten des Feldes für die Normalen Berechnung etwas verbessert werden.

\section{Zusammenfassung}

Das Projekt hat letztendlich die meisten gesetzten, sowie einige optionale, Ziele erreicht. Ein realistisches Wasserverhalten durch SPH mit zusätzlicher Oberflaechenspannung wurde erfolgreich umgesetzt. Die zunächst optionale GPU Implementierung und Spatial Hashing sorgten dafür, dass die gewünschte Menge an Partikeln mit stabiler Frameanzahl simuliert werden konnten. Abstriche mussten allerdings in Sachen Visualisierung gemacht werden, da in dem Projekt der Fokus hauptsächlich auf die physikalische Simulation gelegt wurde. Weitere Zusätze wie die Interaktion mit Objekten und die Komplexität des Wasserstroms wurden aus zeitlichen Gründen nicht implementiert, eigenen sich aber gut, um sie im Rahmen eines weiteren Projekts umzusetzen.
\iffalse
Die anfänglich genannten technischen Herausforderungen GPU Programmierung und Unity Interaktion sind im finalen Produkt fest integriert. Als hinderlich stellten sich im Verlauf des Projekts vor allem die Wahl passender Parameter sowie das Debuggen von GPU Code heraus.
\fi


%% <--------------------------------------------------------------
%% <--------------------------------------------------------------
\bibliographystyle{plainnat}
\bibliography{references}

\end {document}