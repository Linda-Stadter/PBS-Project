\documentclass[a4paper]{paper} 
\usepackage[ngerman]{babel}  
\usepackage[margin=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{natbib}
\renewcommand{\eqref}[1]{Eq.~(\ref{#1})}
\newcommand{\figref}[1]{Fig.~\ref{#1}}
\sloppy

%% <---------------- fill according to your project --------------
\newcommand{\ProjectTitle}{Echtzeit SPH Wasserkanal}
\newcommand{\StudentNames}{Peter Wichert, Kirill Menke, Linda Stadter}
%% <--------------------------------------------------------------

\sectionfont{\large\sf\bfseries\color{black!70!blue}} 
\title{Physikalisch-basierte Simulation in der Computergraphik}
\subtitle{Schriftliche Ausarbeitung\\
\hfill\includegraphics[height=2cm]{fau-logo-tech.pdf}
\vspace{-2cm}}
\author{\ProjectTitle} 
\begin{document} 
\twocolumn[\maketitle 
\textbf{\StudentNames} \\
\hrule\bigskip
]

%% <--------------------------------------------------------------
%% <--------------------------------------------------------------

\section{Einleitung} 
%Bla Bla über Wassersimulationen und über #SPH 
%vll irgendwas mit blender oder so

Das Projekt soll einen realistischen Wasserfluss in einer begrenzten 3D-Umgebung in Echtzeit simulieren. %TODO vll satz über nromales partikelverhalten (zittern ect) sowie box interaktion
Als Inspiration dient das Kinderspielzeug 'Aquaplay', bei dem Kinder über Schleusen, Kurbeln, Pumpen oder Schranken den Wasserfluss veraendern können. 

%Eine finale Simulation soll das Wasser in Bewegung in einer Art Kanal/Fluss sehen.
Zur Visualisierung des Wassers sollen zunächst kugelförmige Objekte dienen, welche durch Screen Space Rendering oder Marching Cubes zu realistisch aussehendem Wasser erweitert werden könnten. 

Für ein ausreichend detailliertes Verhalten der Simulation werden etwa 30.000 Partikel simuliert. Als Kriterium für Echtzeitanforderungen sollen 30 Bilder pro Sekunde erreicht werden. Dies soll auf handelsüblicher Hardware wie der NVIDIA RTX 2070 möglich sein, ohne die Anzahl der Partikel zu verringern. 

\section{Theorie}
%hier muesste eigentlich auch etwas hin, aber kein plan... 
\subsection{Stand der Forschung}
Die Methode der Geglaetteten Teilchen-Hydrodynamik (SPH) wurde erstmalig von Gingold und Monaghan \citep{gingold1977smoothed} und Lucy \citep{lucy1977numerical} vorgestellt. Dabei wurde sie verwendet, um astrophysikalische Probleme wie die Dynamiken von Sternen darzustellen.

Müller et al. \citep{muller2003particle} wandte SPH zuerst für Computergrafik Simulationen in Echtzeit an. Es wurde eine Methode gefunden, die schnell genug war, bis zu 5.000 Partikel in interaktiven Systemen abzubilden.


\subsection{SPH}

Bei SPH wird die zu simulierende Flüssigkeit durch eine endliche Anzahl an Partikeln diskretisiert. Die Partikel interagieren innerhalb eines bestimmten Radius $h$ miteinander und besitzen eigene physikalische Eigenschaften wie  Dichte, Masse oder Druck.

Die Nachbarpartikel eines Partikels sind die Menge der Partikel, welche sich innerhalb von $h$ befinden und somit Einfluss auf den Partikel besitzen. Die Suche dieser Nachbarpartikel stellt einen sehr aufwaendigen Schritt des SPH-Algorithmus dar. Um diese effizient zu finden, teilen wir den Raum in ein uniformes Gitter auf. Eine Zelle besitzt die Grösse des Radius $h$, sodass die Nachbarpartikel nur in den anliegenden 26 Zellen und in der Zelle des Partikels gesucht werden müssen. Durch ihre Positionen im Raum werden die Partikel je einer Zelle zugewiesen. Dies erfolgt durch Spatial Hashing, damit eine endliche Anzahl an Zellen für einen unendlich grossen Raum ausreicht. Dann können die Partikel anhand ihrer zugewiesenen Zelle sortiert werden. Für jede Zelle wird der Abstand zu dem ersten Partikel der Zelle gespeichert. Diese Idee wurde 2008 von Nvidia vorgestellt. \citep{Nvidia}
\begin{equation}
\label{force}
\vec{f} = \vec{f}^{pressure} + \vec{f}^{viscosity} + \vec{f}^{external}
\end{equation}


\begin{equation}
\label{density}
\rho_i = \sum_i{m_j W_{ij}}
\end{equation}



\begin{equation}
\label{pressure}
p_i=K(\rho-\rho_0)
\end{equation}

\begin{equation}
\label{pressure_tait}
p_i = k((\frac{\rho}{\rho_{0}})^{\gamma}-1)
\end{equation}

\begin{equation}
\label{force_pressure}
\vec{f}^{\text{pressure}}_{i} = - \sum_{j}m_{j}(\frac{p_{i}}{\rho_{i}^2} +\frac{p_{j}}{\rho_{j}^2})\bigtriangledown W(\vec{r}_{i}-\vec{r}_{j},h)
\end{equation}

\begin{equation}
\label{force_external}
\vec{f}^{\text{external}}_{i} = \vec{g}
\end{equation}

\begin{equation}
\label{force_viscosity}
\vec{f}^{\text{viscosity}}_{i} = \mu \sum_{j}m_{j}\frac{\vec{v}_{i} - \vec{v}_{j}}{\rho_{j}}\bigtriangledown^2 W(\vec{r}_{i}-\vec{r}_{j},h)
\end{equation}

\paragraph{Smoothing Kernels}

\begin{equation}
\label{poly6}
W_{poly6}(\vec{r},h) = \frac{315}{64 \pi h^9} 
\begin{cases}
(h^2-|\vec{r}|^2)^3, & \text{falls } 0 \leq |\vec{r}| \leq h \\
0, & \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{gradient_poly6}
\bigtriangledown W_{poly6}(\vec{r},h) = \frac{945}{32 \pi h^9} 
\begin{cases}
\vec{r}(h^2-|\vec{r}|^2)^2, \\ \text{falls } 0 \leq |\vec{r}| \leq h  \\
\\
0, \\ \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{spiky}
\bigtriangledown W_{spiky}(\vec{r},h) = -\frac{45}{\pi h^6} (h^2-r^2)^3
\begin{cases}
\frac{\vec{r}}{|\vec{r}|}(h-|r|)^2, \\ \text{falls } 0 \leq |\vec{r}| \leq h\\

\\ 0, \\ \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{viscosity}
\bigtriangledown^2 W_{viscosity}(\vec{r},h) = \frac{45}{\pi h^9} 
\begin{cases}
(h-|r|),

\\ \text{falls} 0 \leq |\vec{r}| \leq h \\
\\
0, 
\\ \text{sonst}
\end{cases}
\end{equation}


\paragraph{Oberflächenspannung}
Um ein überzeugendes Verhalten bei Wasserspritzern und an der Wasseroberflaeche zu erzeugen wird zusätzlich die molekulare Attraktion und Repulsion zwischen Wassermolekülen modelliert.

Eine neü Kraft für Oberflächenspannung wird wie folgt in die bisherige Kraftberechnung eingefügt:
\begin{equation}
\label{force_with_surface}
\vec{f} = \vec{f}^{pressure} + \vec{f}^{viscosity} + \vec{f}^{external} + \vec{f}^{surface}
\end{equation}


Das molekulare Verhalten wird durch \eqref{cohesion} ausgedrückt. $\gamma$ sei hier ein von uns wählbarer Köffizient.

Die Spline-Funktion aus \eqref{spline} sorgt ab einem gewählten Radius $h$ für die zunächst anziehende Wirkung, sowie den ansteigenden abstoßenden Effekt, sollten zwei Partikel zu nahe beieinander sein.

\begin{equation}
\label{spline}
C(r) = \frac{32}{64 \pi h^9}
\begin{cases}
(h-r)^3r^3,  &\text{falls }  2r > h \land r \leq h\\
2(h-r)^3r^3, &\text{falls } r  0 \land 2r \leq h\\
0,&\text{sonst}  
\end{cases}
\end{equation}



\begin{equation}
\label{cohesion}
\vec{f}_{i\leftarrow j}^{\text{cohesion}} = \gamma m_{i} m_{j} C(|\vec{x}_i - \vec{x}_j|)\frac{\vec{x}_i - \vec{x}_j}{|\vec{x}_i - \vec{x}_j|}
\end{equation}


Um zu verhindern, dass beim Formen eines Tropfens durch Oberflächenspannung, die Ausgangsposition der betroffenen Partikel maßgeblich die finale Form beeinflusst, fügen wir eine weitere Kraft aus \eqref{curvature} hinzu.
Diese sorgt dafür, dass Partikel-Mengen unabhängig von Ausgangsposition versuchen eine Kugelform einzunehmen und dadurch die Oberfläche ihres Tropfens minimieren.

Zunächst wird für jedes Partikel ein Normal-Vektor wie in \eqref{normal} berechnet. Hier sollen sich Partikel an der Oberfläche von denen innerhalb eines Wasserkörpers dadurch unterscheiden, dass letztere einen Normal-Vektor von $\sim \vec{0}$ besitzen. Hier würde das Benutzen eines geglättetes Feldes optimale Ergebnisse erreichen. (?)

\begin{equation}
\label{normal}
\vec{n}_{i} = h\sum_{j}\frac{m_{j}}{\rho_{j}}\bigtriangledown W (\vec{r}_{i}-\vec{r}_{j},h)
\end{equation}

\begin{equation}
\label{curvature}
\vec{f}_{i\leftarrow j}^{\text{curvature}} = -\gamma m_{i}(\vec{n}_i - \vec{n}_j)
\end{equation}

Um den Zusammenhalt von wenigen Partikeln an den von grösseren Gruppen anzugleichen, wird in \eqref{surface_tension} ein Korrekturfaktor beim Zusammensetzen (?) der Oberflächenspannung eingeführt.

\begin{equation}
	\label{surface_tension}
	\vec{f}_{i\leftarrow j}^{\text{surface}} = \frac{2\rho_{0}}{\rho_{i}+\rho_{j}} (\vec{f}_{i\leftarrow j}^{\text{cohesion}} + \vec{f}_{i\leftarrow j}^{\text{curvature}})
\end{equation}


\subsection{Integration}

Der Raum der Partikel wird durch eine quadratische Box begrenzt. Kollisionen mit den Seiten der Box werden durch einfache Positionsabfragen behandelt. Diese verhindern, dass die Partikel die Begrenzungen überschreiten. Ausserdem werden die Geschwindigkeiten der entsprechenden Richtungen umgekehrt. Eine Dämpfungsvariable wird eingeführt, die die Geschwindigkeit dabei zusätzlich abmildern kann.

\section{Implementierung}
Das Projekt wird in der Laufzeit und Entwicklungsumgebung Unity implementiert. Dazu wird ein sogenanntes GameObject erstellt, welches ein eigens geschriebenes C\#-Skript zugewiesen wird. Dieses Skript wird verwendet, um die Simulation zu initialisieren und aufzurufen. %Dabei werden zunächst die notwendigen Arrays, Buffer, Partikel und Shader initialisiert.
Ein Zeitschritt wird mithilfe der Update-Funktion von Unity einmal pro Frame durchgeführt. Der eigentliche SPH-Algorithmus wird auf sieben Shader aufgeteilt, welche von der GPU ausgeführt werden. Es ist je ein Shader dafür zuständig, die Buffer zu initialisieren, die Partikel in Zellen einzuteilen, die Partikel anhand ihrer Zelle zu sortieren, die Dichte und im Anschluss die Force eines Partikels zu berechnen und zum Schluss den Integrationsschritt durchzuführen.

Die Positionen in x-,y- und z-Richtung werden gehasht, um daraus den Zellindex zu bestimmen. Um die Anzahl der Hash-Kollisionen möglichst gering zu halten, werden 8-stellige Primzahlen und eine grosse Anzahl an Partikeln - und damit auch Zellen - benutzt.

Für das Sortieren der Partikel anhand ihrer zugewiesenen Zelle wird eine fertige Implementierung des Algorithmus Bitonisches Sortieren verwendet. Dieser Sortieralgorithmus kann parallel auf der GPU ausgeführt werden.

Das Einbeziehen der Nachbarpartikel bei der Berechnung der Dichte und im Anschluss der Force wird im Dichte- und im Force-Shader auf ähnliche Weise implementiert. Hierbei muss über die 27 möglichen Nachbarzellen iteriert werden. Mithilfe des zuvor gespeicherten Abstands kann dann effizient auf alle Partikel einer bestimmten Nachbarzelle zugegriffen werden. Zusätzlich wird überprüft, ob der Abstand zwischen den Partikeln kleiner als der Radius $h$ ist.

Im Integrations-Shader wird neben der Berechnung der Position und der Geschwindigkeit auch die Kollision mit der Box behandelt.

Die Partikel werden in der Update-Funktion in jedem Frame gerendert. Dazu wird eine von Unity vorgegebene Zeichen-Funktion aufgerufen, welche das gleiche Kugel-Mesh parallel auf der GPU zeichnet. Dadurch verhindern wir den unnötigen Overhead, eigenständige GameObjects pro Partikel zu erstellen. In diesem Schritt werden die Partikel anhand ihrer Dichte in einen blassen bis kräftigen Blauton gefärbt.

Neben dem GameObject, welches die Simulation behandelt, werden auch weitere Objekte benötigt. Der Raum, in welchem sich die Partikel bewegen können, wird durch eine Box begrenzt, welche zur Laufzeit erzeugt wird. Die Box wird dabei durch ein eigenes Skript kontrolliert, welches die Positionen der Seitenplatten anhand einer vorgegebenen Bodenplatte berechnet.
Ausserdem werden zwei Nutzeroberflächen benötigt, um Parameter einerseits vor dem Beginn der Simulation wie in Bild \ref{fig:interface1} und andererseits während der laufenden Simulation wie in Bild \ref{fig:interface2} einstellen und anpassen zu können. Dazu werden fertige UI-Elemente von Unity verwendet. Beim Starten der Simulation findet ein Szenenwechsel statt. Dadurch werden nicht mehr benötigte Objekte entfernt und neue Objekte eingeblendet.

\begin{figure}[t]
    \centering
    \includegraphics[width=1\linewidth]{images/interface1.png}
    \caption{öberfläche vor dem Starten der Simulation, um die entsprechenden Parameter der Simulation einzustellen.}
    \label{fig:interface1}
\end{figure}

\begin{figure}[t]
    \centering
    \includegraphics[width=1\linewidth]{images/interface2.png}
    \caption{öberfläche während der Simulation, um die Parameter des SPH-Algorithmus anzupassen.}
    \label{fig:interface2}
\end{figure}

\section{Ergebnisse und Evaluierung}
Bild von Test mit Boxspawn
Bild von Explosion
2 Bilder von Finalem mit Rohr (1 leer 1 voll)

+ ein paar simulations zahlen

\section{Beiträge}
Kirill Menke hat über den SPH-Algorithmus recherchiert und die Methode gefunden, wie 
effizient auf die Nachbarpartikel zugegriffen werden kann. Er hat das Grundgerüst der Simulation in Unity aufgesetzt, sodass die einzelnen Schritte des SPH-Algorithmus auf der GPU ausgeführt werden können. Zusätzlich hat er das Rendering der Partikel implementiert , bei der Umsetzung des SPH-Algorithmus mitgewirkt und einen Modus zum vereinfachten Debuggen eingeführt. Ausserdem hat er die Milestonepräsentation erstellt und vorgetragen. 

Linda Stadter hat ebenfalls bei der Umsetzung des SPH-Algorithmus mitgewirkt. Zusätzlich hat sie sich um das Erzeugen der Box und die Kollisionen der Kugeln mit den Seiten gekümmert. Zusätzlich hat sie die beiden Nutzeroberflächen umgesetzt, die Farbcodierung der Partikel eingeführt und ein kontinuierliches Erzeugen der Partikel umgesetzt. Ausserdem hat sie die Porjektplanpräsentation erstellt und vorgetragen, bei der Milestonepräsentation mitgewirkt und den finalen Bericht geschrieben.

Peter Wichert hat über die Leapfrog Integration und Oberflächenspannung recherchiert und diese implementiert. Zusätzlich hat er eine automatische Berechnung der Parameter eingeführt und den Debug-Modus ergänzt. Ausserdem hat er die Milestone Präsentation erstellt und vorgetragen und den finalen Bericht geschrieben.



\section{Diskussion}
Durch das Verwendung von Spatial Hashing und der Sortierung nach Zellen lässt sich die Laufzeit der aufwändigen Suche der Nachbarpartikel von $O(n^2)$ auf $O(n)$ reduzieren.
In Kombination mit der parallelen Ausführung des SPH-Algorithmus auf der GPU lassen sich grosse Anzahlen an Partikeln in Echtzeit simulieren.

Merge Sort kann nur 2-er Potenzen von Partikel.
Echtzeitperformance würde etwas schlechter werden mit dem Extra Render Schritten.
Echtzeitperformance würde vermutlich ein stück schlechter werden mit Festkörper Interaktion. 


Hash-Collisions lassen sich leider nicht vermeiden und fallen bei einer sehr geringen Anzahl an Partikeln auf. Daher werden diese geringen Partikelanzahlen von der Simulation ausgeschlossen.
\section{Zusammenfassung}

Das Projekt hat letztendlich die meisten gesetzten, sowie einige optionale, Ziele erreicht. Ein realistisches Wasserverhalten durch SPH mit zusätzlicher Oberflächenspannung wurde erfolgreich umgesetzt. Die zunächst optionale GPU Implementierung und Spatial Hashing sorgten dafür, dass die gewünschte Menge an Partikeln mit stabiler Frameanzahl simuliert werden konnten. Abstriche mussten allerdings in Sachen Visualisierung gemacht werden, da in dem Projekt der Fokus hauptsächlich auf die physikalische Simulation gelegt wurde. Weitere Zusätze wie die Interaktion mit Objekten und die Komplexität des Wasserstroms wurden aus zeitlichen Gründen nicht implementiert, eigenen sich aber gut, um sie im Rahmen eines weiteren Projekts umzusetzen.


%% <--------------------------------------------------------------
%% <--------------------------------------------------------------
\bibliographystyle{plainnat}
\bibliography{references}

\end {document}