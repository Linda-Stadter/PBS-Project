\documentclass[a4paper]{paper} 
\usepackage[ngerman]{babel}  
\usepackage[margin=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{natbib}
\renewcommand{\eqref}[1]{Eq.~(\ref{#1})}
\newcommand{\figref}[1]{Fig.~\ref{#1}}
\sloppy

%% <---------------- fill according to your project --------------
\newcommand{\ProjectTitle}{Echtzeit SPH Wasserkanal}
\newcommand{\StudentNames}{Peter Wichert, Kirill Menke, Linda Stadter}
%% <--------------------------------------------------------------

\sectionfont{\large\sf\bfseries\color{black!70!blue}} 
\title{Physikalisch-basierte Simulation in der Computergraphik}
\subtitle{Schriftliche Ausarbeitung\\
\hfill\includegraphics[height=2cm]{fau-logo-tech.pdf}
\vspace{-2cm}}
\author{\ProjectTitle} 
\begin{document} 
\maketitle 
\textbf{\StudentNames} \\
\hrule\bigskip


%% <--------------------------------------------------------------
%% <--------------------------------------------------------------

\section{Einleitung} 
\subsection{Hintergrund}

%Bla Bla über Wassersimulationen und über #SPH 
%vll irgendwas mit blender oder so


\subsection{Ziele}
Das Projekt soll einen realistischen Wasserfluss in einer begrenzten 3D-Umgebung in Echtzeit simulierten. %TODO vll satz über nromales partikelverhalten (zittern ect) sowie box interaktion
Eine finale Simulation soll das Wasser in Bewegung in einer Art Kanal/Fluss sehen.
Zur Visualisierung sollen zunächst kugelförmige Objekte dienen und später Screen Space Rendering oder Marching Cubes benutzt werden. 
 Für ausreichend detailliertes Verhalten der Simulation werden ~30.000 Partikel simuliert. Als Kriterium für Echtzeitanforderungen sollen 30 Bilder pro Sekunde auf Hardware, die zum Zeitpunkt des Projekts in einem normalen PC zu finden sein kann, erreichbar sein, ohne die Anzahl der Partikel zu verringern. 
\subsection{Methoden}
SPH
Tait
Surface


\section{Theorie}
\subsection{Related Work}%TODO deutsch
\subsection{SPH}
\subsubsection{Oberflächenspannung}
\subsubsection{Smoothing Kernels}



\begin{equation}
\label{poly6}
W_{poly6}(\vec{r},h) = \frac{315}{64 \pi h^9} 
\begin{cases}
(h^2-|\vec{r}|^2)^3, & \text{falls } 0 \leq |\vec{r}| \leq h \\
0, & \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{gradient_poly6}
\bigtriangledown W_{poly6}(\vec{r},h) = \frac{945}{32 \pi h^9} 
\begin{cases}
\vec{r}(h^2-|\vec{r}|^2)^2, &\text{falls } 0 \leq |\vec{r}| \leq h  \\
0, & \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{spiky}
\bigtriangledown W_{spiky}(\vec{r},h) = -\frac{45}{\pi h^6} (h^2-r^2)^3
\begin{cases}
 \frac{\vec{r}}{|\vec{r}|}(h-|r|)^2, & \text{falls } 0 \leq |\vec{r}| \leq h\\
0, & \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{viscosity}
\bigtriangledown^2 W_{viscosity}(\vec{r},h) = \frac{45}{\pi h^9} 
\begin{cases}
(h-|r|),& \text{falls} 0 \leq |\vec{r}| \leq h \\
0, & \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{surface}
C(r) = \frac{32}{64 \pi h^9}
\begin{cases}
(h-r)^3r^3,  &\text{falls }  2r > h \land r \leq h\\
2(h-r)^3r^3, &\text{falls } r  0 \land 2r \leq h\\
0,&\text{sonst}  
\end{cases}
\end{equation}


\begin{equation}
\label{surface_tension}
\vec{f}_{i\leftarrow j}^{\text{surface}} = \frac{2\rho_{0}}{\rho_{i}+\rho_{j}} (\vec{f}_{i\leftarrow j}^{\text{cohesion}} + \vec{f}_{i\leftarrow j}^{\text{curvature}})
\end{equation}


\begin{equation}
\label{curvature}
\vec{f}_{i\leftarrow j}^{\text{curvature}} = -\gamma m_{i}(\vec{n}_i - \vec{n}_j)
\end{equation}

\begin{equation}
\vec{n}_{i} = h\sum_{j}\frac{m_{j}}{\rho_{j}}\bigtriangledown W (\vec{r}_{i}-\vec{r}_{j},h)
\end{equation}

\begin{equation}
\label{cohesion}
\vec{f}_{i\leftarrow j}^{\text{cohesion}} = \gamma m_{i} m_{j} C(|\vec{x}_i - \vec{x}_j|)\frac{\vec{x}_i - \vec{x}_j}{|\vec{x}_i - \vec{x}_j|}
\end{equation}

\subsection{Integration}




Die Suche der Nachbarpartikel stellt einen sehr aufwaendigen Schritt des SPH-Algorithmus dar. Die Nachbarpartikel eines Partikels sind die Menge der Partikel, welche sich innerhalb eines bestimmten Radius $h$ befinden und somit Einfluss auf den Partikel besitzen. Um diese effizient zu finden, teilen wir den Raum in ein uniformes Gitter auf. Eine Zelle besitzt die Groesse des Radius $h$, sodass die Nachbarpartikel nur in den anliegenden 26 Zellen und in der Zelle des Partikels gesucht werden muessen. Durch ihre Positionen im Raum werden die Partikel je einer Zelle zugewiesen. Dies erfolgt durch Spatial Hashing, damit eine endliche Anzahl an Zellen fuer einen unendlich grossen Raum ausreicht. Dann koennen die Partikel anhand ihrer zugewiesenen Zelle sortiert werden. Fuer jede Zelle wird der Abstand zu dem ersten Partikel der Zelle gespeichert. Diese Idee wurde 2008 von Nvidia vorgestellt. \ref{Nvidia}

Die Dichte wird dabei wie in der Gleichung \ref{density} mithilfe eines Poly6 Smoothing Kernels $W_{ij}$ aus Gleichung \ref{poly6} berechnet.
\begin{equation}
\label{density}
\rho_i = \sum_i{m_j W_{ij}}
\end{equation}

\begin{equation}
\label{poly6}
W_{ij} = \frac{315}{64 \pi h^9} (h^2-r^2)^3
\end{equation}

Der Druck $p_i$ wird mit der Gaskonstanten $K$ und dem Referenzdruck $\rho_0$ in Gleichung \ref{pressure} berechnet.

\begin{equation}
\label{pressure}
p_i = k(\rho-\rho_0)
\end{equation}

\begin{equation}
\label{pressure_tait}
p_i = k((\frac{\rho}{\rho_{0}})^{\gamma}-1)
\end{equation}

Die Force $f$ aus Gleichung \ref{force} kann als Addition der drei einzelnen Forces pressure, viscosity und external berechnet werden.

\begin{equation}
\label{force}
\vec{f} = \vec{f}^{pressure} + \vec{f}^{viscosity} + \vec{f}^{external}
\end{equation}

\begin{equation}
\label{force_with_surface}
\vec{f} = \vec{f}^{pressure} + \vec{f}^{viscosity} + \vec{f}^{external} + \vec{f}^{surface}
\end{equation}


\begin{equation}
\label{force_pressure}
\vec{f}^{\text{pressure}}_{i} = - \sum_{j}m_{j}(\frac{p_{i}}{\rho_{i}^2} +\frac{p_{j}}{\rho_{j}^2})\bigtriangledown W(\vec{r}_{i}-\vec{r}_{j},h)
\end{equation}
	
	\begin{equation}
\label{force_external}
\vec{f}^{\text{external}}_{i} = \vec{g}
\end{equation}

\begin{equation}
\label{force_viscosity}
\vec{f}^{\text{viscosity}}_{i} = \mu \sum_{j}m_{j}\frac{\vec{v}_{i} - \vec{v}_{j}}{\rho_{j}}\bigtriangledown^2 W(\vec{r}_{i}-\vec{r}_{j},h)
\end{equation}


\section{Implementierung}
\subsection{Übersicht}
\subsection{Unity}
Das Projekt wird in der Laufzeit und Entwicklungsumgebung Unity implementiert. Dazu wird ein sogenanntes GameObject erstellt, welches ein eigens geschriebenes C\#-Skript zugewiesen wird. Dieses Skript wird verwendet, um die Simulation zu initialisieren und aufzurufen. %Dabei werden zunaechst die notwendigen Arrays, Buffer, Partikel und Shader initialisiert.
Ein Zeitschritt wird mithilfe der Update-Funktion von Unity einmal pro Frame durchgefuehrt. Der eigentliche SPH-Algorithmus wird auf sieben Shader aufgeteilt, welche von der GPU ausgefuehrt werden.
 Es ist je ein Shader dafuer zustaendig, die Buffer zu initialisieren, die Partikel in Zellen einzuteilen, die Partikel anhand ihrer Zelle zu sortieren, die Dichte und im Anschluss die Force eines Partikels zu berechnen und zum Schluss den Integrationsschritt durchzufuehren.
\subsection{Spatial Hashing}%TODO deutsch
Die Positionen in x-,y- und z-Richtung werden gehasht, um daraus den Zellindex zu bestimmen. Um die Anzahl der Hash-Kollisionen moeglichst gering zu halten, werden 8-stellige Primzahlen und eine grosse Anzahl an Partikeln - und damit auch Zellen - benutzt.

Fuer das Sortieren der Partikel anhand ihrer zugewiesenen Zelle wird eine fertige Implementierung des Algorithmus Bitonisches Sortieren verwendet. Dieser Sortieralgorithmus kann parallel auf der GPU ausgefuehrt werden.

\subsection{Compute Shader}

\subsection{Rendering}
\subsection{Performance}



Das Einbeziehen der Nachbarpartikel bei der Berechnung der Dichte und im Anschluss der Force wird auf aehnliche Weise implementiert. Hierbei muss nur ueber die 27 moeglichen Nachbarzellen iteriert werden. Mithilfe des zuvor gespeicherten Abstands kann dann effizient auf alle Partikel einer bestimmten Nachbarzelle zugegriffen werden. Zusaetlich muss noch ueberprueft werden, ob der Abstand zu dem Partikel kleiner als der Radius $h$ ist.

Neben dem GameObject, welches die Simulation behandelt, werden auch weitere Objekte benoetigt. Der Raum, in welchem sich die Partikel bewegen koennen, wird durch eine Box begrenzt, welche zur Laufzeit erzeugt wird. Die Box wird dabei durch ein eigenes Skript kontrolliert, welches die Positionen der Seitenplatten anhand einer vorgegebenen Bodenplatte berechnet.
Ausserdem werden zwei Oberflaechen benoetigt, um Parameter einerseits vor dem Beginn der Simulation wie in Bild \ref{fig:interface1} und andererseits waehrend der laufenden Simulation wie in Bild \ref{fig:interface2} einstellen und anpassen zu koennen. Dazu werden fertige UI-Elemente von Unity verwendet. Beim Starten der Simulation findet ein Szenenwechsel statt. Dadurch werden nicht mehr benoetigte Objekte entfernt und neue benoetigte Objekte eingeblendet.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.7\linewidth]{images/interface1.png}
    \caption{Oeberflaeche vor dem Starten der Simulation, um die entsprechenden Parameter der Simulation einzustellen.}
    \label{fig:interface1}
\end{figure}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.7\linewidth]{images/interface2.png}
    \caption{Oeberflaeche waehrend der Simulation, um die Parameter des SPH-Algorithmus anzupassen.}
    \label{fig:interface2}
\end{figure}

\section{Ergebnisse und Evaluierung}
Bild von Test mit Boxspawn
Bild von Explosion
2 Bilder von Finalem mit Rohr (1 leer 1 voll)

+ ein paar simulations zahlen

\section{Diskussion}
Merge Sort kann nur 2-er Potenzen von Partikel.
Echtzeitperformance würde etwas schlechter werden mit dem Extra Render Schritten.
Echtzeitperformance würde vermutlich ein stück schlechter werden mit Festkörper Interaktion. 

\section{Beiträge}
Verteilung der Aufgaben erfolgte meisten spontan nachdem in einem Meeting die nächsten Schritte besprochen wurden.

Auflistung was wer so gemacht hat bei den ??? bin ich nicht sicher
fügt hinzu was fehlt (ist eigentlich relativ gemischt idk ob wir das überhaupt auflisten wollen)

Kirill hält ersten 2 Präsentationen
Peter hält die letzte Präsentation
Erstellen der Präsentationen größtenteils vom Vortragenden mit Hilfe der anderen.
Alle 3 Recherche
%??? Linda und Kirill allgemein Unity
%??? Kirill C# code basis
%??? Linda Unity Box
Linda und Kirill spatial hashing
Peter autom. Parameterberechnung
Peter Leapfrog
??? Kirill Debug Mode (später Peter kleine änderungen für neuen Code/Debug)
Linda Interface und Unity Szenen
Linda und Peter Report

\section{Zusammenfassung}
Das Projekt hat letztendlich die meisten gesetzten, sowie einige optionale, Ziele erreicht. Realistisches Wasserverhalten durch SPH mit zusätzlicher Oberflächenspannung//TODO ä ist gegeben. Die zunächst optionale GPU Implementierung und Spatial Hashing sorgten dafür, dass die gewünschte Menge an Partikeln mit stabiler Frameanzahl simuliert werden konnten. Abstriche mussten allerdings in Sachen Visualisierung, Interaktion mit Objekten und Komplexität des Wasserstroms gemacht werden. 

%% <--------------------------------------------------------------
%% <--------------------------------------------------------------
\bibliographystyle{plainnat}
\bibliography{references}

\end {document}