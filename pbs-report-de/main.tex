\documentclass[a4paper]{paper} 
\usepackage[ngerman]{babel}  
\usepackage[margin=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{natbib}
\usepackage{tabularx}
\renewcommand{\eqref}[1]{Eq.~(\ref{#1})}
\newcommand{\figref}[1]{Fig.~\ref{#1}}
\sloppy

%% <---------------- fill according to your project --------------
\newcommand{\ProjectTitle}{Echtzeit SPH Wasserkanal}
\newcommand{\StudentNames}{Peter Wichert, Kirill Menke, Linda Stadter}
%% <--------------------------------------------------------------

\sectionfont{\large\sf\bfseries\color{black!70!blue}} 
\title{Physikalisch-basierte Simulation in der Computergraphik}
\subtitle{Schriftliche Ausarbeitung\\
\hfill\includegraphics[height=2cm]{fau-logo-tech.pdf}
\vspace{-2cm}}
\author{\ProjectTitle} 
\begin{document} 
\maketitle 
\textbf{\StudentNames} \\
\hrule\bigskip


%% <--------------------------------------------------------------
%% <--------------------------------------------------------------

\section{Einleitung} 
<<<<<<< HEAD
%Bla Bla über Wassersimulationen und über #SPH 
%vll irgendwas mit blender oder so

Das Projekt soll einen realistischen Wasserfluss in einer begrenzten 3D-Umgebung in Echtzeit simulieren. %TODO vll satz über nromales partikelverhalten (zittern ect) sowie box interaktion
Als Inspiration dient das Kinderspielzeug 'Aquaplay', bei dem Kinder ueber Schleusen, Kurbeln, Pumpen oder Schranken den Wasserfluss veraendern koennen. 

%Eine finale Simulation soll das Wasser in Bewegung in einer Art Kanal/Fluss sehen.
Zur Visualisierung des Wassers sollen zunächst kugelförmige Objekte dienen, welche durch Screen Space Rendering oder Marching Cubes zu realistisch aussehendem Wasser erweitert werden koennten. 

Für ein ausreichend detailliertes Verhalten der Simulation werden etwa 30.000 Partikel simuliert. Als Kriterium für Echtzeitanforderungen sollen 30 Bilder pro Sekunde erreicht werden. Dies soll auf handelsueblicher Hardware wie der NVIDIA RTX 2070 moeglich sein, ohne die Anzahl der Partikel zu verringern. 
=======
\subsection{Hintergrund}

%Bla Bla über Wassersimulationen und über #SPH 
%vll irgendwas mit blender oder so
\subsection{Ziele}
Das Projekt soll einen realistischen Wasserfluss in einer begrenzten 3D-Umgebung in Echtzeit simulierten. %TODO vll satz über nromales partikelverhalten (zittern ect) sowie box interaktion
Eine finale Simulation soll das Wasser in Bewegung in einer Art Kanal/Fluss sehen.
Zur Visualisierung sollen zunächst kugelförmige Objekte dienen und später Screen Space Rendering oder Marching Cubes benutzt werden. 
Für ausreichend detailliertes Verhalten der Simulation werden ~30.000 Partikel simuliert. Als Kriterium für Echtzeitanforderungen sollen 30 Bilder pro Sekunde auf Hardware, die zum Zeitpunkt des Projekts in einem normalen PC zu finden sein kann, erreichbar sein, ohne die Anzahl der Partikel zu verringern. 
\subsection{Methoden}
SPH
Tait
Surface
>>>>>>> 7953f5f3b13b54537504bb35e04592d9795b832a

\section{Theorie}
\subsection{Related Work}%TODO deutsch
\subsection{SPH}

\begin{equation}
\label{force}
\vec{f} = \vec{f}^{pressure} + \vec{f}^{viscosity} + \vec{f}^{external}
\end{equation}


<<<<<<< HEAD
\subsection{SPH}

\begin{equation}
\label{force}
\vec{f} = \vec{f}^{pressure} + \vec{f}^{viscosity} + \vec{f}^{external}
\end{equation}


=======
>>>>>>> 7953f5f3b13b54537504bb35e04592d9795b832a
\begin{equation}
\label{density}
\rho_i = \sum_i{m_j W_{ij}}
\end{equation}



\begin{equation}
\label{pressure}
p_i=K(\rho-\rho_0)
\end{equation}

\begin{equation}
\label{force_pressure}
\vec{f}^{\text{pressure}}_{i} = - \sum_{j}m_{j}(\frac{p_{i}}{\rho_{i}^2} +\frac{p_{j}}{\rho_{j}^2})\bigtriangledown W(\vec{r}_{i}-\vec{r}_{j},h)
\end{equation}

\begin{equation}
\label{force_external}
\vec{f}^{\text{external}}_{i} = \vec{g}
\end{equation}

\begin{equation}
\label{force_viscosity}
\vec{f}^{\text{viscosity}}_{i} = \mu \sum_{j}m_{j}\frac{\vec{v}_{i} - \vec{v}_{j}}{\rho_{j}}\bigtriangledown^2 W(\vec{r}_{i}-\vec{r}_{j},h)
\end{equation}

<<<<<<< HEAD
\paragraph{Smoothing Kernels}

=======

\subsubsection{Smoothing Kernels}

\begin{equation}
\label{poly6}
W_{poly6}(\vec{r},h) = \frac{315}{64 \pi h^9} 
\begin{cases}
(h^2-|\vec{r}|^2)^3, & \text{falls } 0 \leq |\vec{r}| \leq h \\
0, & \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{gradient_poly6}
\bigtriangledown W_{poly6}(\vec{r},h) = \frac{945}{32 \pi h^9} 
\begin{cases}
\vec{r}(h^2-|\vec{r}|^2)^2, &\text{falls } 0 \leq |\vec{r}| \leq h  \\
0, & \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{spiky}
\bigtriangledown W_{spiky}(\vec{r},h) = -\frac{45}{\pi h^6} (h^2-r^2)^3
\begin{cases}
\frac{\vec{r}}{|\vec{r}|}(h-|r|)^2, & \text{falls } 0 \leq |\vec{r}| \leq h\\
0, & \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{viscosity}
\bigtriangledown^2 W_{viscosity}(\vec{r},h) = \frac{45}{\pi h^9} 
\begin{cases}
(h-|r|),& \text{falls} 0 \leq |\vec{r}| \leq h \\
0, & \text{sonst}
\end{cases}
\end{equation}

\iffalse
Bei der Geglaetteten Teilchen-Hydrodynamik (SPH) wird die zu simulierende Fluessigkeit durch eine endliche Anzahl an Partikeln diskretisiert. Die Partikel interagieren innerhalb eines bestimmten Radius $h$ miteinander und besitzen eigene physikalische Eigenschaften wie  Dichte, Masse oder Druck.

Die Nachbarpartikel eines Partikels sind die Menge der Partikel, welche sich innerhalb von $h$ befinden und somit Einfluss auf den Partikel besitzen. Die Suche dieser Nachbarpartikel stellt einen sehr aufwaendigen Schritt des SPH-Algorithmus dar. Um diese effizient zu finden, teilen wir den Raum in ein uniformes Gitter auf. Eine Zelle besitzt die Groesse des Radius $h$, sodass die Nachbarpartikel nur in den anliegenden 26 Zellen und in der Zelle des Partikels gesucht werden muessen. Durch ihre Positionen im Raum werden die Partikel je einer Zelle zugewiesen. Dies erfolgt durch Spatial Hashing, damit eine endliche Anzahl an Zellen fuer einen unendlich grossen Raum ausreicht. Dann koennen die Partikel anhand ihrer zugewiesenen Zelle sortiert werden. 

Fuer jede Zelle wird der Abstand zu dem ersten Partikel der Zelle gespeichert. Diese Idee wurde 2008 von Nvidia vorgestellt. \cite{Nvidia}

Die Dichte wird dabei wie in der Gleichung \ref{density} mithilfe eines Poly6 Smoothing Kernels $W_{ij}$ aus Gleichung \ref{poly6} berechnet.\fi

 \iffalse
>>>>>>> 7953f5f3b13b54537504bb35e04592d9795b832a
\begin{equation}
\label{poly6}
W_{poly6}(\vec{r},h) = \frac{315}{64 \pi h^9} 
\begin{cases}
(h^2-|\vec{r}|^2)^3, & \text{falls } 0 \leq |\vec{r}| \leq h \\
0, & \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{gradient_poly6}
\bigtriangledown W_{poly6}(\vec{r},h) = \frac{945}{32 \pi h^9} 
\begin{cases}
\vec{r}(h^2-|\vec{r}|^2)^2, &\text{falls } 0 \leq |\vec{r}| \leq h  \\
0, & \text{sonst}
\end{cases}
\end{equation}

Die Force $f$ aus Gleichung \ref{force} kann als Addition der drei einzelnen Forces pressure, viscosity und external berechnet werden.
\fi

\subsubsection{Oberflächenspannung}
Um akkurates Wasserverhalten in Wasserspritzern und an Grenzen zu Luft zu erzeugen wird zusätzlich die molekulare Attraktion und Repulsion zwischen Wassermolekülen modelliert.

Eine neue Kraft für Oberflächenspannung wird wie folgt in die bisherige Kraftberechnung eingefügt:
\begin{equation}
<<<<<<< HEAD
\label{spiky}
\bigtriangledown W_{spiky}(\vec{r},h) = -\frac{45}{\pi h^6} (h^2-r^2)^3
\begin{cases}
\frac{\vec{r}}{|\vec{r}|}(h-|r|)^2, & \text{falls } 0 \leq |\vec{r}| \leq h\\
0, & \text{sonst}
\end{cases}
\end{equation}

\begin{equation}
\label{viscosity}
\bigtriangledown^2 W_{viscosity}(\vec{r},h) = \frac{45}{\pi h^9} 
\begin{cases}
(h-|r|),& \text{falls} 0 \leq |\vec{r}| \leq h \\
0, & \text{sonst}
\end{cases}
\end{equation}


\paragraph{Oberflächenspannung}
Um akkurates Wasserverhalten in Wasserspritzern und an Grenzen zu Luft zu erzeugen wird zusätzlich die molekulare Attraktion und Repulsion zwischen Wassermolekülen modelliert.

Eine neue Kraft für Oberflächenspannung wird wie folgt in die bisherige Kraftberechnung eingefügt:
\begin{equation}
=======
>>>>>>> 7953f5f3b13b54537504bb35e04592d9795b832a
\label{force_with_surface}
\vec{f} = \vec{f}^{pressure} + \vec{f}^{viscosity} + \vec{f}^{external} + \vec{f}^{surface}
\end{equation}


Das molekulare Verhalten wird durch (\ref{cohesion}) ausgedrückt, $\gamma$ sein hier ein von uns wählbarer Koeffizient.

Die Spline-Funktion (\ref{spline}) sorgt ab einem gewählten Radius $(h)$ für die zunächst anziehende Wirkung, sowie den ansteigenden abstoßenden Effekt, sollten zwei Partikel zu nahe beieinander sein.

\begin{equation}
\label{spline}
C(r) = \frac{32}{64 \pi h^9}
\begin{cases}
(h-r)^3r^3,  &\text{falls }  2r > h \land r \leq h\\
2(h-r)^3r^3, &\text{falls } r  0 \land 2r \leq h\\
0,&\text{sonst}  
\end{cases}
\end{equation}



\begin{equation}
\label{cohesion}
\vec{f}_{i\leftarrow j}^{\text{cohesion}} = \gamma m_{i} m_{j} C(|\vec{x}_i - \vec{x}_j|)\frac{\vec{x}_i - \vec{x}_j}{|\vec{x}_i - \vec{x}_j|}
\end{equation}


Um zu verhindern, dass beim Formen eines Tropfens durch Oberflächenspannung, die Ausgangsposition der betroffenen Partikel maßgeblich die finale Form beeinflusst, fügen wir eine weitere Kraft (\ref{curvature}) hinzu.
Diese sorgt dafür, dass Partikel-Mengen unabhängig von Ausgangsposition versuchen eine Kugelform einzunehmen und dadurch die Oberfläche ihres Tropfens minimieren.

Zunächst wird für jedes Partikel ein Normal-Vektor berechnet (\ref{normal}). Hier sollen sich Partikel an der Oberfläche von denen innerhalb eines Wasserkörpers dadurch unterscheiden, dass letztere einen Normal-Vektor von $\sim \vec{0}$ besitzen. Hier würde das Benutzen ein geglättetes Feld optimale Ergebnisse erreichen.

\begin{equation}
\label{normal}
\vec{n}_{i} = h\sum_{j}\frac{m_{j}}{\rho_{j}}\bigtriangledown W (\vec{r}_{i}-\vec{r}_{j},h)
<<<<<<< HEAD
=======
\end{equation}

\begin{equation}
\label{curvature}
\vec{f}_{i\leftarrow j}^{\text{curvature}} = -\gamma m_{i}(\vec{n}_i - \vec{n}_j)
\end{equation}

Um den Zusammenhalt von wenigen Partikel an den von Gruppen mit mehreren Anzugleichen, wird des weiteren ein Korrekturfaktor beim Zusammensetzen Oberflächenspannung eingeführt(\ref{surface_tension}).

\begin{equation}
	\label{surface_tension}
	\vec{f}_{i\leftarrow j}^{\text{surface}} = \frac{2\rho_{0}}{\rho_{i}+\rho_{j}} (\vec{f}_{i\leftarrow j}^{\text{cohesion}} + \vec{f}_{i\leftarrow j}^{\text{curvature}})
\end{equation}




\iffalse
\begin{equation}
	\label{density}
	\rho_i = \sum_i{m_j W_{ij}}
\end{equation}

\begin{equation}
	\label{poly6}
	W_{ij} = \frac{315}{64 \pi h^9} (h^2-r^2)^3
>>>>>>> 7953f5f3b13b54537504bb35e04592d9795b832a
\end{equation}
\fi




<<<<<<< HEAD
\begin{equation}
\label{curvature}
\vec{f}_{i\leftarrow j}^{\text{curvature}} = -\gamma m_{i}(\vec{n}_i - \vec{n}_j)
\end{equation}

Um den Zusammenhalt von wenigen Partikel an den von Gruppen mit mehreren Anzugleichen, wird des weiteren ein Korrekturfaktor beim Zusammensetzen Oberflächenspannung eingeführt(\ref{surface_tension}).

\begin{equation}
	\label{surface_tension}
	\vec{f}_{i\leftarrow j}^{\text{surface}} = \frac{2\rho_{0}}{\rho_{i}+\rho_{j}} (\vec{f}_{i\leftarrow j}^{\text{cohesion}} + \vec{f}_{i\leftarrow j}^{\text{curvature}})
\end{equation}
=======

>>>>>>> 7953f5f3b13b54537504bb35e04592d9795b832a


\subsection{Integration}

Der Raum der Partikel wird durch eine quadratische Box begrenzt. Kollisionen mit den Seiten der Box werden durch einfache Positionsabfragen behandelt. Diese verhindern, dass die Partikel die Begrenzungen ueberschreiten. Ausserdem werden die Geschwindigkeiten der entsprechenden Richtungen umgekehrt. Eine Daempfungsvariable wird eingefuehrt, die die Geschwindigkeit dabei zusaetzlich abmildern kann.

\section{Implementierung}
\subsection{Übersicht}
\subsection{Unity}

\subsection{Compute Shader}

\subsection{Rendering}
\subsection{Performance}
Das Projekt wird in der Laufzeit und Entwicklungsumgebung Unity implementiert. Dazu wird ein sogenanntes GameObject erstellt, welches ein eigens geschriebenes C\#-Skript zugewiesen wird. Dieses Skript wird verwendet, um die Simulation zu initialisieren und aufzurufen. %Dabei werden zunaechst die notwendigen Arrays, Buffer, Partikel und Shader initialisiert.
Ein Zeitschritt wird mithilfe der Update-Funktion von Unity einmal pro Frame durchgefuehrt. Der eigentliche SPH-Algorithmus wird auf sieben Shader aufgeteilt, welche von der GPU ausgefuehrt werden. Es ist je ein Shader dafuer zustaendig, die Buffer zu initialisieren, die Partikel in Zellen einzuteilen, die Partikel anhand ihrer Zelle zu sortieren, die Dichte und im Anschluss die Force eines Partikels zu berechnen und zum Schluss den Integrationsschritt durchzufuehren.

Die Positionen in x-,y- und z-Richtung werden gehasht, um daraus den Zellindex zu bestimmen. Um die Anzahl der Hash-Kollisionen moeglichst gering zu halten, werden 8-stellige Primzahlen und eine grosse Anzahl an Partikeln - und damit auch Zellen - benutzt.

Fuer das Sortieren der Partikel anhand ihrer zugewiesenen Zelle wird eine fertige Implementierung des Algorithmus Bitonisches Sortieren verwendet. Dieser Sortieralgorithmus kann parallel auf der GPU ausgefuehrt werden.

Das Einbeziehen der Nachbarpartikel bei der Berechnung der Dichte und im Anschluss der Force wird im Dichte- und im Force-Shader auf aehnliche Weise implementiert. Hierbei muss ueber die 27 moeglichen Nachbarzellen iteriert werden. Mithilfe des zuvor gespeicherten Abstands kann dann effizient auf alle Partikel einer bestimmten Nachbarzelle zugegriffen werden. Zusaetzlich wird ueberprueft, ob der Abstand zwischen den Partikeln kleiner als der Radius $h$ ist.

Im Integrations-Shader wird neben der Berechnung der Position und der Geschwindigkeit auch die Kollision mit der Box behandelt.

Die Partikel werden in der Update-Funktion in jedem Frame gerendert. Dazu wird eine von Unity vorgegebene Zeichen-Funktion aufgerufen, welche das gleiche Kugel-Mesh parallel auf der GPU zeichnet. Dadurch verhindern wir den unnoetigen Overhead, eigenstaendige GameObjects pro Partikel zu erstellen. In diesem Schritt werden die Partikel anhand ihrer Dichte in einen blassen bis kraeftigen Blauton gefaerbt.

Neben dem GameObject, welches die Simulation behandelt, werden auch weitere Objekte benoetigt. Der Raum, in welchem sich die Partikel bewegen koennen, wird durch eine Box begrenzt, welche zur Laufzeit erzeugt wird. Die Box wird dabei durch ein eigenes Skript kontrolliert, welches die Positionen der Seitenplatten anhand einer vorgegebenen Bodenplatte berechnet.
Ausserdem werden zwei Nutzeroberflaechen benoetigt, um Parameter einerseits vor dem Beginn der Simulation wie in Bild \ref{fig:interface1} und andererseits waehrend der laufenden Simulation wie in Bild \ref{fig:interface2} einstellen und anpassen zu koennen. Dazu werden fertige UI-Elemente von Unity verwendet. Beim Starten der Simulation findet ein Szenenwechsel statt. Dadurch werden nicht mehr benoetigte Objekte entfernt und neue Objekte eingeblendet.

\begin{figure}[t]
    \centering
    \includegraphics[width=1\linewidth]{images/interface1.png}
    \caption{Oeberflaeche vor dem Starten der Simulation, um die entsprechenden Parameter der Simulation einzustellen.}
    \label{fig:interface1}
\end{figure}

\begin{figure}[t]
    \centering
    \includegraphics[width=1\linewidth]{images/interface2.png}
    \caption{Oeberflaeche waehrend der Simulation, um die Parameter des SPH-Algorithmus anzupassen.}
    \label{fig:interface2}
\end{figure}

\section{Ergebnisse und Evaluierung}
Bild von Test mit Boxspawn
Bild von Explosion
2 Bilder von Finalem mit Rohr (1 leer 1 voll)

+ ein paar simulations zahlen

\section{Beiträge}
Verteilung der Aufgaben erfolgte meisten spontan nachdem in einem Meeting die nächsten Schritte besprochen wurden.
\begin{center}
\begin{tabularx}{\textwidth}{ 
		| >{\raggedright\arraybackslash}X 
		| >{\raggedright\arraybackslash}X 
		| >{\raggedright\arraybackslash}X | }
\hline
Peter Wichert & Kirill Menke & Linda Stadter\\
\hline \hline
\begin{itemize}
\item Erstellen der Projektplan Präsentation
\item Erstellen der Milestone Präsentation
\item Erstellen und Vortragen der finalen Präsentation
\item Erstellen des finalen Berichts
\item Recherche für eigene und gruppenrelevante Themen
\item Leapfrog Integration
\item Surface Tension
\item Particle Spawn
\item Parameter Berechnung
\item Ergänzen des Debug Modus
\item Debugging eigener und anderer Implementierungen
\end{itemize}
&
\begin{itemize}
\item Erstellen und Vortragen der Projektplan Präsentation
\item Erstellen und Vortragen der Milestone Präsentation
\item Erstellen der finalen Präsentation
\item Recherche für eigene und gruppenrelevante Themen
\item C\# und Compute Shader Grundgerüst
\item Unity Grundstruktur
\item Spatial Hashing und Nearest Neighbour Search
\item Rendering
\item Implementierung des Debug Modus
\item Stabilitäts Tests
\item Debugging eigener und anderer Implementierungen
\end{itemize}
&
\begin{itemize}
\item Erstellen der Projektplan Präsentation
\item Erstellen der Milestone Präsentation
\item Erstellen der finalen Präsentation
\item Erstellen des finalen Berichts
\item Recherche für eigene und gruppenrelevante Themen
\item Unity Grundstruktur
\item Spatial Hashing und Nearest Neighbour Search
\item Simulationsumgebung und Kollisionen
\item Finaler kontinuierlicher Partikel Spawn
\item Interface
\item Unity Szenen
\item Farbcodierung der Partikel
\item Debugging eigener und anderer Implementierungen
\end{itemize}
\\
\hline

\end{tabularx}
\end{center}

\iffalse

Kirill Menke hat ueber den SPH-Algorithmus recherchiert und die Methode gefunden, wie 
effizient auf die Nachbarpartikel zugegriffen werden kann. Er hat das Grundgeruest der Simulation in Unity aufgesetzt, sodass die einzelnen Schritte des SPH-Algorithmus auf der GPU ausgefuehrt werden koennen. Zusaetzlich hat er das Rendering der Partikel implementiert , bei der Umsetzung des SPH-Algorithmus mitgewirkt und einen Modus zum vereinfachten Debuggen eingefuehrt. Ausserdem hat er die Milestonepraesentation erstellt und vorgetragen. 

Linda Stadter hat ebenfalls bei der Umsetzung des SPH-Algorithmus mitgewirkt. Zuesatzlich hat sie sich um das Erzeugen der Box und die Kollisionen der Kugeln mit den Seiten gekuemmert. Zusaetzlich hat sie die beiden Nutzeroberflaechen umgesetzt, die Farbcodierung der Partikel eingefuehrt und ein kontinuierliches Erzeugen der Partikel umgesetzt. Ausserdem hat sie die Porjektplanpraesentation erstellt und vorgetragen, bei der Milestonepraesentation mitgewirkt und den finalen Bericht geschrieben.

Peter Wichert hat ueber die Leapfrog Integration und Oberflaechenspannung recherchiert und diese implementiert. Zusaetzlich hat er eine automatische Berechnung der Parameter eingefuehrt und den Debug-Modus ergaenzt. Ausserdem hat er die Milestone Praesentation erstellt und vorgetragen und den finalen Bericht geschrieben.



<<<<<<< HEAD
=======
Peter Wichert
\fi





>>>>>>> 7953f5f3b13b54537504bb35e04592d9795b832a
\section{Diskussion}
Durch das Verwendung von Spatial Hashing und der Sortierung nach Zellen laesst sich die Laufzeit der aufwaendigen Suche der Nachbarpartikel von $O(n^2)$ auf $O(n)$ reduzieren.
In Kombination mit der parallelen Ausfuehrung des SPH-Algorithmus auf der GPU lassen sich grosse Anzahlen an Partikeln in Echtzeit simulieren.

<<<<<<< HEAD
=======

>>>>>>> 7953f5f3b13b54537504bb35e04592d9795b832a
Merge Sort kann nur 2-er Potenzen von Partikel.
Echtzeitperformance würde etwas schlechter werden mit dem Extra Render Schritten.
Echtzeitperformance würde vermutlich ein stück schlechter werden mit Festkörper Interaktion. 

<<<<<<< HEAD

=======
>>>>>>> 7953f5f3b13b54537504bb35e04592d9795b832a
Hash-Collisions lassen sich leider nicht vermeiden und fallen bei einer sehr geringen Anzahl an Partikeln auf. Daher werden diese geringen Partikelanzahlen von der Simulation ausgeschlossen.
\section{Zusammenfassung}
Das Projekt hat letztendlich die meisten gesetzten, sowie einige optionale, Ziele erreicht. Realistisches Wasserverhalten durch SPH mit zusätzlicher Oberflächenspannung//TODO ä ist gegeben. Die zunächst optionale GPU Implementierung und Spatial Hashing sorgten dafür, dass die gewünschte Menge an Partikeln mit stabiler Frameanzahl simuliert werden konnten. Abstriche mussten allerdings in Sachen Visualisierung, Interaktion mit Objekten und Komplexität des Wasserstroms gemacht werden.



Das Projekt hat letztendlich die meisten gesetzten, sowie einige optionale, Ziele erreicht. Ein realistisches Wasserverhalten durch SPH mit zusätzlicher Oberflächenspannung wurde erfolgreich umgesetzt. Die zunächst optionale GPU Implementierung und Spatial Hashing sorgten dafür, dass die gewünschte Menge an Partikeln mit stabiler Frameanzahl simuliert werden konnten. Abstriche mussten allerdings in Sachen Visualisierung gemacht werden, da in dem Projekt der Fokus hauptsaechlich auf die physikalische Simulation gelegt wurde. Weitere Zusaetze wie die Interaktion mit Objekten und die Komplexität des Wasserstroms wurden aus zeitlichen Gruenden nicht implementiert, eigenen sich aber gut, um sie im Rahmen eines weiteren Projekts umzusetzen.


%% <--------------------------------------------------------------
%% <--------------------------------------------------------------
\bibliographystyle{plainnat}
\bibliography{references}

\end {document}