#include "./Globals.cginc"
#pragma kernel calcForce1
#pragma kernel calcForce2

RWStructuredBuffer<float3> forceBuffer;
RWStructuredBuffer<float3> debug1;
RWStructuredBuffer<float3> debug2;
RWStructuredBuffer<float3> normalsBuffer;

StructuredBuffer<FluidParticle> particlesBuffer;
StructuredBuffer<uint> particlesIndexBuffer;
StructuredBuffer<float> cellIndexBuffer;
StructuredBuffer<uint> offsetBuffer;
StructuredBuffer<float> densityBuffer;

uint particleCount;
float h, h_inv, h2, h3;
float poly6, spiky, spline;
float mass;
float K;
float p0;
float e;
float3 g;
float surface_coefficient;

//DOESN'T USE 1/2 POSITION AND VELOCITY

[numthreads(THREADS, 1, 1)]
void calcForce1(uint3 id : SV_DispatchThreadID)
{

	uint particleIdxA = particlesIndexBuffer[id.x];
	float densityA = densityBuffer[particleIdxA];

	FluidParticle particleA = particlesBuffer[particleIdxA];
	float3 posA = particleA.pos;

	// Grid cell is of size [SPH smoothing radius], so position is refitted into that
	const float3 remappedPos = posA * h_inv;
	const int3 cellIndex = floor(remappedPos);

	// Compute acceleration:
	float3 force_total = forceBuffer[particleIdxA];
	float3 f_press = 0;
	float3 f_vis = 0;
	float3 f_surface = 0;
	float3 normalA = normalsBuffer[particleIdxA];
	float pressureA = max((K * p0 / 7) * (pow(((densityA) / p0), 7) - 1),0);
	float spline_sub = pow(h, 6) / 64;


	// iterate through all [27] neighbor cells:
	[loop]
	for (int i = -1; i <= 1; ++i)
	{
		[loop]
		for (int j = -1; j <= 1; ++j)
		{
			[loop]
			for (int k = -1; k <= 1; ++k)
			{
				// hashed cell index is retrieved:
				const int3 neighborIndex = cellIndex + int3(i, j, k);
				const uint flatNeighborIndex = SPH_GridHash(neighborIndex, particleCount);

				// look up the offset into particle list from neighbor cell:
				uint neighborIterator = offsetBuffer[flatNeighborIndex];

				// iterate through neighbor cell particles (if iterator offset is valid):
				[loop]
				while (neighborIterator != 0x7FFFFFFF && neighborIterator < particleCount)
				{
					uint particleIdxB = particlesIndexBuffer[neighborIterator];
					if ((uint)cellIndexBuffer[neighborIterator] != flatNeighborIndex)
					{
						// here means we stepped out of the neighbor cell list!
						break;
					}

					// SPH Force evaluation:
					FluidParticle particleB = particlesBuffer[particleIdxB];
					float3 posB = particleB.pos;

					const float3 diff = posA - posB;
					const float r2 = dot(diff, diff);
					const float r = sqrt(r2);
					const float r3 = pow(r,3);
					const float revdensA2 = 1 / pow(densityA, 2);

					if (r > 0 && r < h)
					{
						
						// Normalize distance between particles
						const float3 rNorm = diff / r;
						// Spiky kernel smoothing for pressure forces
						

						//PRESSURE
						const float3 Wpress = spiky * pow(h - r, 2) * rNorm;
						float densityB = densityBuffer[particleIdxB];										
						float pressureB = max((K * p0 / 7) * (pow(((densityB) / p0), 7) - 1), 0);
						f_press += mass * (pressureA * revdensA2 + pressureB / pow(densityB, 2)) * Wpress;

						//VISCOCITY
						const float Wvis = -spiky * (h - r);
						float3 vDiff = particleB.v - particleA.v;
						f_vis += mass * (vDiff / densityB) * Wvis;

						

						//SURFACE TENSION
						float spline_C = spline;
						if (2 * r > h && r <= h)
						{
							spline_C *= pow((h-r),3)*r3;
						}
						else if (2 * r <= h && r > 0)
						{
							spline_C *= 2*pow((h - r), 3) * r3 - spline_sub;
						}
						else
						{
							spline_C = 0;
						}

						float3 f_cohesion = -surface_coefficient * mass * mass * spline_C * rNorm;
						

						float3 normalB = normalsBuffer[particleIdxB];
						float3 f_curvature = -surface_coefficient*mass*(normalA  - normalB); 

						float corr_fact_K = 2 * p0 / (densityA + densityB);

						f_surface += corr_fact_K*(f_cohesion + f_curvature);
						//f_surface += f_cohesion;
						
						debug1[particleIdxA] = float3(corr_fact_K, corr_fact_K, corr_fact_K); //check corr fakt
						//debug1[particleIdxA] = f_curvature; //check curvature



					}

					neighborIterator++;
				}
			}
		}
	}

	f_press *= -1;
	f_vis *= e;

	debug2[particleIdxA] = f_surface;

	force_total = (f_press + f_vis+f_surface) / densityA+g;
	forceBuffer[particleIdxA] = force_total;
}


//DOES USE 1/2 POSITION AND VELOCITY
[numthreads(THREADS, 1, 1)]
void calcForce2(uint3 id : SV_DispatchThreadID)
{

	uint particleIdxA = particlesIndexBuffer[id.x];
	float densityA = densityBuffer[particleIdxA];

	FluidParticle particleA = particlesBuffer[particleIdxA];
	float3 posA = particleA.posLF;

	// Grid cell is of size [SPH smoothing radius], so position is refitted into that
	const float3 remappedPos = posA * h_inv;
	const int3 cellIndex = floor(remappedPos);

	// Compute acceleration:
	float3 force_total = forceBuffer[particleIdxA];
	float3 f_press = 0;
	float3 f_vis = 0;
	float3 f_surface = 0;
	float3 normalA = normalsBuffer[particleIdxA];
	float pressureA = max((K * p0 / 7) * (pow(((densityA) / p0), 7) - 1), 0);
	float spline_sub = pow(h, 6) / 64;


	// iterate through all [27] neighbor cells:
	[loop]
	for (int i = -1; i <= 1; ++i)
	{
		[loop]
		for (int j = -1; j <= 1; ++j)
		{
			[loop]
			for (int k = -1; k <= 1; ++k)
			{
				// hashed cell index is retrieved:
				const int3 neighborIndex = cellIndex + int3(i, j, k);
				const uint flatNeighborIndex = SPH_GridHash(neighborIndex, particleCount);

				// look up the offset into particle list from neighbor cell:
				uint neighborIterator = offsetBuffer[flatNeighborIndex];

				// iterate through neighbor cell particles (if iterator offset is valid):
				[loop]
				while (neighborIterator != 0x0FFFFFFF && neighborIterator < particleCount)
				{
					uint particleIdxB = particlesIndexBuffer[neighborIterator];
					if ((uint)cellIndexBuffer[neighborIterator] != flatNeighborIndex)
					{
						// here means we stepped out of the neighbor cell list!
						break;
					}

					// SPH Force evaluation:
					FluidParticle particleB = particlesBuffer[particleIdxB];
					float3 posB = particleB.posLF;

					const float3 diff = posA - posB;
					const float r2 = dot(diff, diff);
					const float r = sqrt(r2);
					const float revdensA2 = 1/ pow(densityA, 2);
					const float r3 = pow(r, 3);

					if (r > 0 && r < h)
					{
						// Normalize distance between particles
						const float3 rNorm = diff / r;


						//PRESSURE
						const float3 Wpress = spiky * pow(h - r, 2);
						float densityB = densityBuffer[particleIdxB];
						float pressureB = max((K * p0 / 7) * (pow(((densityB) / p0), 7) - 1), 0);
						
						f_press += mass * (pressureA *revdensA2  + pressureB / pow(densityB, 2)) * Wpress * rNorm;

						//VISCOCITY

						const float Wvis = -spiky * (h - r);
						float3 vDiff = particleB.vLF - particleA.vLF;
						f_vis += mass * (vDiff/ densityB) * Wvis;


						//SURFACE TENSION
						float spline_C = spline;
						if (2 * r > h && r <= h)
						{
							//spline_C *= pow((h - r), 3) * r3;
							spline_C = 0;
						}
						else if (2 * r <= h && r > 0)
						{
							spline_C *= 2 * pow((h - r), 3) * r3 - spline_sub;
						}
						else
						{
							spline_C = 0;
						}

						float3 f_cohesion = -surface_coefficient * mass * mass * spline_C * rNorm; //no mass aswell???
						float3 normalB = normalsBuffer[particleIdxB];
						float3 f_curvature = -surface_coefficient * mass * (normalA - normalB); //other formula doesnt use mass

						float corr_fact_K = 2 * p0 / (pressureA + pressureB);

						f_surface += corr_fact_K * (f_cohesion + f_curvature);

					}

					neighborIterator++;
				}
			}
		}
	}

	f_press *= -1;
	f_vis *= e;

	force_total = (f_press + f_vis+f_surface) / densityA +g;

	forceBuffer[particleIdxA] = force_total;
}
