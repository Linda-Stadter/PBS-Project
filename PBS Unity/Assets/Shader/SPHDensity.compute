#include "./SPHGlobals.cginc"
#pragma kernel calcDensity


RWStructuredBuffer<float> densityBuffer;
RWStructuredBuffer<float3> debugBuffer;

StructuredBuffer<FluidParticle> particlesBuffer;
StructuredBuffer<uint> particlesIndexBuffer;
StructuredBuffer<float> cellIndexBuffer;
StructuredBuffer<uint> offsetBuffer;

[numthreads(THREADS,1,1)]
void calcDensity(uint3 id : SV_DispatchThreadID)
{
	const float h = xSPH_h;			// smoothing radius
	const float h2 = xSPH_h2;		// smoothing radius ^ 2
	const float h3 = xSPH_h3;		// smoothing radius ^ 3
	const float K = xSPH_K;			// pressure constant
	const float p0 = xSPH_p0;		// reference density
	const float e = xSPH_e;			// viscosity constant

	uint particleIdxA = particlesIndexBuffer[id.x];
	float3 posA = particlesBuffer[particleIdxA].pos;
	
    // Grid cell is of size [SPH smoothing radius], so position is refitted into that
	const float3 remappedPos = posA * xSPH_h_rcp;
	const int3 cellIndex = floor(remappedPos);

    // Compute density field:
	float density = 0;

	// iterate through all [27] neighbor cells:
	// -1 to +1 only applies for a grid cell size of 1 (grid cell size = h)
	uint c = 0;
	[loop]
	for (int i = -1; i <= 1; ++i)
	{
		[loop]
		for (int j = -1; j <= 1; ++j)
		{
			[loop]
			for (int k = -1; k <= 1; ++k)
			{
				c = c + 1;
				// hashed cell index is retrieved:
				const int3 neighborIndex = cellIndex + int3(i, j, k);
				const uint flatNeighborIndex = SPH_GridHash(neighborIndex);

				// look up the offset into particle list from neighbor cell:
				uint neighborIterator = offsetBuffer[flatNeighborIndex];

				// iterate through neighbor cell particles (if iterator offset is valid):
				[loop]
				while (neighborIterator != 0x0FFFFFFF && neighborIterator < PARTICLE_COUNT)
				{

					uint particleIdxB = particlesIndexBuffer[neighborIterator];
					if ((uint)cellIndexBuffer[particleIdxB] != flatNeighborIndex)
					{
						// here means we stepped out of the neighbor cell list!
						break;
					}


					// SPH Density evaluation:
					FluidParticle particleB = particlesBuffer[particleIdxB];

					float3 diff = posA - particleB.pos;
					float r2 = dot(diff, diff); // distance squared

					if (r2 < 1.0) // h2
					{
						float W = xSPH_poly6_constant * pow(h2 - r2, 3);
						density += xSPH_mass * W;

						debugBuffer[c + (id.x * 27 * 2)] = posA;
						debugBuffer[c + 1 + (id.x * 27 * 2)] = particleB.pos;
					}
					

					neighborIterator++;
				}
			}
		}
	}


    
	// Can't be lower than reference density to avoid negative pressure!
	// density = max(1.0, density); // xSPH_h

	// Store the result
	densityBuffer[particleIdxA] = density;
	

}
