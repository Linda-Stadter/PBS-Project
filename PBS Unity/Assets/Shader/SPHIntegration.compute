#include "./SPHGlobals.cginc"

#pragma kernel calcIntegration

RWStructuredBuffer<FluidParticle> particlesBuffer;

StructuredBuffer<uint> particlesIndexBuffer;
StructuredBuffer<float> densityBuffer;
StructuredBuffer<float3> forceBuffer;

float3 minBoxBoundarys;
float3 maxBoxBoundarys;

bool Leapfrog;
bool IsLFtime;

[numthreads(THREADS, 1, 1)]
void calcIntegration(uint3 id : SV_DispatchThreadID)
{
    const float3 g = xSPH_g;
    const float width = xSPH_width;
    const float damping = xSPH_damping;
    const float deltaTime = 0.005f;

    // force integration
    uint particleIdx = particlesIndexBuffer[id.x];
    FluidParticle particleA = particlesBuffer[particleIdx];

    if (Leapfrog) {
        
        if (IsLFtime) {
            particleA.vLF = particleA.v + 0.5 * deltaTime * forceBuffer[particleIdx];
            particleA.posLF = particleA.pos + 0.5 * deltaTime * particleA.v;
        } else {
            particleA.v += deltaTime * forceBuffer[particleIdx];
            particleA.pos += deltaTime * 0.5 * (particleA.v + particleA.vLF);
        }

    } 
    /* Forward Euler */
    else {
        particleA.v += deltaTime * forceBuffer[particleIdx];
        particleA.pos += deltaTime * particleA.v;
    }

    
    if (!IsLFtime) {
        // box collision using edges of ground
        if (particleA.pos.x < minBoxBoundarys.x) {
            particleA.pos.x = minBoxBoundarys.x;
            particleA.v.x = -particleA.v.x * damping;
        } 
        else if (particleA.pos.x > maxBoxBoundarys.x) {
            particleA.pos.x = maxBoxBoundarys.x;
            particleA.v.x = -particleA.v.x * damping;
        }
        
        if (particleA.pos.y < minBoxBoundarys.y) {
            particleA.pos.y = minBoxBoundarys.y;
            particleA.v.y = -particleA.v.y * damping;
        } 
        
        if (particleA.pos.z < minBoxBoundarys.z) {
            particleA.pos.z = minBoxBoundarys.z;
            particleA.v.z = -particleA.v.z * damping;
        }
        else if (particleA.pos.z > maxBoxBoundarys.z) {
            particleA.pos.z = maxBoxBoundarys.z;
            particleA.v.z = -particleA.v.z * damping;
        }

        // Ignore box ceiling for now
        /* else if (particleA.pos.y > width) {
            particleA.pos.y = width;
            particleA.v.y = -particleA.v.y * damping;
        } */
    }

    particlesBuffer[particleIdx] = particleA;
}
