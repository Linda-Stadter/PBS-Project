#include "./SPHGlobals.cginc"

#pragma kernel calcIntegration

RWStructuredBuffer<FluidParticle> particlesBuffer;
RWStructuredBuffer<uint> particlesIndexBuffer;
StructuredBuffer<float> densityBuffer;
StructuredBuffer<float> forceBuffer;
float deltaTime;


[numthreads(THREADS, 1, 1)]
void calcIntegration(uint3 id : SV_DispatchThreadID)
{
    const float3 g = xSPH_g;
    const float width = xSPH_width;
    const float damping = xSPH_damping;

    // force integration
    uint particleIdx = particlesIndexBuffer[id.x];

    FluidParticle particleA = particlesBuffer[particleIdx];
    particleA.v += deltaTime * (forceBuffer[particleIdx] / densityBuffer[particleIdx] + g);
    particleA.pos += deltaTime * particleA.v;


    // box collision
    if (particleA.pos.x < -width) {
        particleA.pos.x = -width;
        particleA.v.x = -particleA.v.x * damping;
    } 
    else if (particleA.pos.x > width) {
        particleA.pos.x = width;
        particleA.v.x = -particleA.v.x * damping;
    }

    if (particleA.pos.y < -width) {
        particleA.pos.y = -width;
        particleA.v.y = -particleA.v.y * damping;
    } /*
    else if (particleA.pos.y > width) {
        particleA.pos.y = width;
        particleA.v.y = -particleA.v.y * damping;
    } */

    if (particleA.pos.z < -width) {
        particleA.pos.z = -width;
        particleA.v.z = -particleA.v.z * damping;
    }
    else if (particleA.pos.z > width) {
        particleA.pos.z = width;
        particleA.v.z = -particleA.v.z * damping;
    }


    
    
    particlesBuffer[particleIdx] = particleA;
}
